• Briefly describe the client (The Gaming Room) and their requirements for software.
Draw It or Lose It is a game developed by The Gaming Room. The client wanted to expand the game across multiple platforms. Their key requirement was a detailed Software Design Document (SDD) that would evaluate various platforms and architecture options while ensuring the final design would be scalable, memory-efficient, and compatible with a range of devices.

• What worked really well for you with creating this documentation?
I was able to translate complex technical concepts into language that a client could easily understand. I also organized the document effectively, covering system architecture, memory and storage management, platform compatibility, and distributed system considerations in a professional and concise way.

• What parts of the process of working through a design document were helpful as you wrote the code?
Creating the design document helped me visualize how each subsystem should interact. It served as a blueprint for development, guiding decisions about dependencies, performance trade-offs, and scalability before any code was even written.

• If you could rewrite one part of your work on these documents, what would you choose? How would you improve it?
I would revise the section on distributed system design. I would add diagrams and clearly explain communication protocols and fault-tolerance strategies to make the section more accessible to both technical and non-technical readers.

• How did you comprehend what a user wanted and point to their needs and help with their outcome in your design choices? Why does it even matter to think about the user when designing?
I interpreted the user's needs by analyzing the nature of the game—real-time, multiplayer interaction across various platforms with consistent performance. Considering the user’s needs is essential because it leads to more intuitive, efficient, and satisfying software experiences.

• How did you create software that cares? What sort of techniques or methodology would you use in the future to analyze and design this type of software application?
I followed a structured approach that included requirement modeling, platform comparison, and architectural evaluation. In future projects, I would continue using UML diagrams, develop detailed user stories, and prioritize efficient memory management to deliver robust and flexible software tailored to client needs.
